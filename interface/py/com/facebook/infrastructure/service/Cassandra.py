#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
import fb303.FacebookService
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(fb303.FacebookService.Iface):
  def get_slice(self, tablename, key, columnFamily_column, start, count):
    pass

  def get_column(self, tablename, key, columnFamily_column):
    pass

  def get_column_count(self, tablename, key, columnFamily_column):
    pass

  def insert_blocking(self, tablename, key, columnFamily_column, cellData, timestamp):
    pass

  def insert(self, tablename, key, columnFamily_column, cellData, timestamp):
    pass

  def batch_insert(self, batchMutation):
    pass

  def batch_insert_blocking(self, batchMutation):
    pass

  def remove(self, tablename, key, columnFamily_column):
    pass

  def get_slice_super(self, tablename, key, columnFamily_superColumnName, start, count):
    pass

  def get_superColumn(self, tablename, key, columnFamily):
    pass

  def batch_insert_superColumn(self, batchMutationSuper):
    pass

  def batch_insert_superColumn_blocking(self, batchMutationSuper):
    pass


class Client(fb303.FacebookService.Client, Iface):
  def __init__(self, iprot, oprot=None):
    fb303.FacebookService.Client.__init__(self, iprot, oprot)

  def get_slice(self, tablename, key, columnFamily_column, start, count):
    self.send_get_slice(tablename, key, columnFamily_column, start, count)
    return self.recv_get_slice()

  def send_get_slice(self, tablename, key, columnFamily_column, start, count):
    self._oprot.writeMessageBegin('get_slice', TMessageType.CALL, self._seqid)
    args = get_slice_args()
    args.tablename = tablename
    args.key = key
    args.columnFamily_column = columnFamily_column
    args.start = start
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_slice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_slice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_slice failed: unknown result");

  def get_column(self, tablename, key, columnFamily_column):
    self.send_get_column(tablename, key, columnFamily_column)
    return self.recv_get_column()

  def send_get_column(self, tablename, key, columnFamily_column):
    self._oprot.writeMessageBegin('get_column', TMessageType.CALL, self._seqid)
    args = get_column_args()
    args.tablename = tablename
    args.key = key
    args.columnFamily_column = columnFamily_column
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_column(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_column_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_column failed: unknown result");

  def get_column_count(self, tablename, key, columnFamily_column):
    self.send_get_column_count(tablename, key, columnFamily_column)
    return self.recv_get_column_count()

  def send_get_column_count(self, tablename, key, columnFamily_column):
    self._oprot.writeMessageBegin('get_column_count', TMessageType.CALL, self._seqid)
    args = get_column_count_args()
    args.tablename = tablename
    args.key = key
    args.columnFamily_column = columnFamily_column
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_column_count(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_column_count_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_column_count failed: unknown result");

  def insert_blocking(self, tablename, key, columnFamily_column, cellData, timestamp):
    self.send_insert_blocking(tablename, key, columnFamily_column, cellData, timestamp)
    self.recv_insert_blocking()

  def send_insert_blocking(self, tablename, key, columnFamily_column, cellData, timestamp):
    self._oprot.writeMessageBegin('insert_blocking', TMessageType.CALL, self._seqid)
    args = insert_blocking_args()
    args.tablename = tablename
    args.key = key
    args.columnFamily_column = columnFamily_column
    args.cellData = cellData
    args.timestamp = timestamp
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_insert_blocking(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = insert_blocking_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def insert(self, tablename, key, columnFamily_column, cellData, timestamp):
    self.send_insert(tablename, key, columnFamily_column, cellData, timestamp)

  def send_insert(self, tablename, key, columnFamily_column, cellData, timestamp):
    self._oprot.writeMessageBegin('insert', TMessageType.CALL, self._seqid)
    args = insert_args()
    args.tablename = tablename
    args.key = key
    args.columnFamily_column = columnFamily_column
    args.cellData = cellData
    args.timestamp = timestamp
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def batch_insert(self, batchMutation):
    self.send_batch_insert(batchMutation)

  def send_batch_insert(self, batchMutation):
    self._oprot.writeMessageBegin('batch_insert', TMessageType.CALL, self._seqid)
    args = batch_insert_args()
    args.batchMutation = batchMutation
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def batch_insert_blocking(self, batchMutation):
    self.send_batch_insert_blocking(batchMutation)
    return self.recv_batch_insert_blocking()

  def send_batch_insert_blocking(self, batchMutation):
    self._oprot.writeMessageBegin('batch_insert_blocking', TMessageType.CALL, self._seqid)
    args = batch_insert_blocking_args()
    args.batchMutation = batchMutation
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_batch_insert_blocking(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = batch_insert_blocking_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "batch_insert_blocking failed: unknown result");

  def remove(self, tablename, key, columnFamily_column):
    self.send_remove(tablename, key, columnFamily_column)

  def send_remove(self, tablename, key, columnFamily_column):
    self._oprot.writeMessageBegin('remove', TMessageType.CALL, self._seqid)
    args = remove_args()
    args.tablename = tablename
    args.key = key
    args.columnFamily_column = columnFamily_column
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def get_slice_super(self, tablename, key, columnFamily_superColumnName, start, count):
    self.send_get_slice_super(tablename, key, columnFamily_superColumnName, start, count)
    return self.recv_get_slice_super()

  def send_get_slice_super(self, tablename, key, columnFamily_superColumnName, start, count):
    self._oprot.writeMessageBegin('get_slice_super', TMessageType.CALL, self._seqid)
    args = get_slice_super_args()
    args.tablename = tablename
    args.key = key
    args.columnFamily_superColumnName = columnFamily_superColumnName
    args.start = start
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_slice_super(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_slice_super_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_super failed: unknown result");

  def get_superColumn(self, tablename, key, columnFamily):
    self.send_get_superColumn(tablename, key, columnFamily)
    return self.recv_get_superColumn()

  def send_get_superColumn(self, tablename, key, columnFamily):
    self._oprot.writeMessageBegin('get_superColumn', TMessageType.CALL, self._seqid)
    args = get_superColumn_args()
    args.tablename = tablename
    args.key = key
    args.columnFamily = columnFamily
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_superColumn(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_superColumn_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_superColumn failed: unknown result");

  def batch_insert_superColumn(self, batchMutationSuper):
    self.send_batch_insert_superColumn(batchMutationSuper)

  def send_batch_insert_superColumn(self, batchMutationSuper):
    self._oprot.writeMessageBegin('batch_insert_superColumn', TMessageType.CALL, self._seqid)
    args = batch_insert_superColumn_args()
    args.batchMutationSuper = batchMutationSuper
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def batch_insert_superColumn_blocking(self, batchMutationSuper):
    self.send_batch_insert_superColumn_blocking(batchMutationSuper)
    return self.recv_batch_insert_superColumn_blocking()

  def send_batch_insert_superColumn_blocking(self, batchMutationSuper):
    self._oprot.writeMessageBegin('batch_insert_superColumn_blocking', TMessageType.CALL, self._seqid)
    args = batch_insert_superColumn_blocking_args()
    args.batchMutationSuper = batchMutationSuper
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_batch_insert_superColumn_blocking(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = batch_insert_superColumn_blocking_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "batch_insert_superColumn_blocking failed: unknown result");


class Processor(fb303.FacebookService.Processor, Iface, TProcessor):
  def __init__(self, handler):
    fb303.FacebookService.Processor.__init__(self, handler)
    self._processMap["get_slice"] = Processor.process_get_slice
    self._processMap["get_column"] = Processor.process_get_column
    self._processMap["get_column_count"] = Processor.process_get_column_count
    self._processMap["insert_blocking"] = Processor.process_insert_blocking
    self._processMap["insert"] = Processor.process_insert
    self._processMap["batch_insert"] = Processor.process_batch_insert
    self._processMap["batch_insert_blocking"] = Processor.process_batch_insert_blocking
    self._processMap["remove"] = Processor.process_remove
    self._processMap["get_slice_super"] = Processor.process_get_slice_super
    self._processMap["get_superColumn"] = Processor.process_get_superColumn
    self._processMap["batch_insert_superColumn"] = Processor.process_batch_insert_superColumn
    self._processMap["batch_insert_superColumn_blocking"] = Processor.process_batch_insert_superColumn_blocking

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_get_slice(self, seqid, iprot, oprot):
    args = get_slice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_slice_result()
    result.success = self._handler.get_slice(args.tablename, args.key, args.columnFamily_column, args.start, args.count)
    oprot.writeMessageBegin("get_slice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_column(self, seqid, iprot, oprot):
    args = get_column_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_column_result()
    result.success = self._handler.get_column(args.tablename, args.key, args.columnFamily_column)
    oprot.writeMessageBegin("get_column", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_column_count(self, seqid, iprot, oprot):
    args = get_column_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_column_count_result()
    result.success = self._handler.get_column_count(args.tablename, args.key, args.columnFamily_column)
    oprot.writeMessageBegin("get_column_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insert_blocking(self, seqid, iprot, oprot):
    args = insert_blocking_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = insert_blocking_result()
    self._handler.insert_blocking(args.tablename, args.key, args.columnFamily_column, args.cellData, args.timestamp)
    oprot.writeMessageBegin("insert_blocking", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insert(self, seqid, iprot, oprot):
    args = insert_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.insert(args.tablename, args.key, args.columnFamily_column, args.cellData, args.timestamp)
    return

  def process_batch_insert(self, seqid, iprot, oprot):
    args = batch_insert_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.batch_insert(args.batchMutation)
    return

  def process_batch_insert_blocking(self, seqid, iprot, oprot):
    args = batch_insert_blocking_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = batch_insert_blocking_result()
    result.success = self._handler.batch_insert_blocking(args.batchMutation)
    oprot.writeMessageBegin("batch_insert_blocking", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_remove(self, seqid, iprot, oprot):
    args = remove_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.remove(args.tablename, args.key, args.columnFamily_column)
    return

  def process_get_slice_super(self, seqid, iprot, oprot):
    args = get_slice_super_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_slice_super_result()
    result.success = self._handler.get_slice_super(args.tablename, args.key, args.columnFamily_superColumnName, args.start, args.count)
    oprot.writeMessageBegin("get_slice_super", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_superColumn(self, seqid, iprot, oprot):
    args = get_superColumn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_superColumn_result()
    result.success = self._handler.get_superColumn(args.tablename, args.key, args.columnFamily)
    oprot.writeMessageBegin("get_superColumn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_batch_insert_superColumn(self, seqid, iprot, oprot):
    args = batch_insert_superColumn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.batch_insert_superColumn(args.batchMutationSuper)
    return

  def process_batch_insert_superColumn_blocking(self, seqid, iprot, oprot):
    args = batch_insert_superColumn_blocking_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = batch_insert_superColumn_blocking_result()
    result.success = self._handler.batch_insert_superColumn_blocking(args.batchMutationSuper)
    oprot.writeMessageBegin("batch_insert_superColumn_blocking", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class get_slice_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.tablename = None
    self.key = None
    self.columnFamily_column = None
    self.start = -1
    self.count = -1
    if isinstance(d, dict):
      if 'tablename' in d:
        self.tablename = d['tablename']
      if 'key' in d:
        self.key = d['key']
      if 'columnFamily_column' in d:
        self.columnFamily_column = d['columnFamily_column']
      if 'start' in d:
        self.start = d['start']
      if 'count' in d:
        self.count = d['count']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRING:
          self.columnFamily_column = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.I32:
          self.start = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, -1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, -2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnFamily_column != None:
      oprot.writeFieldBegin('columnFamily_column', TType.STRING, -3)
      oprot.writeString(self.columnFamily_column)
      oprot.writeFieldEnd()
    if self.start != None:
      oprot.writeFieldBegin('start', TType.I32, -4)
      oprot.writeI32(self.start)
      oprot.writeFieldEnd()
    if self.count != None:
      oprot.writeFieldBegin('count', TType.I32, -5)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_result:

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(column_t, column_t.thrift_spec)), None, ), # 0
  )

  def __init__(self, d=None):
    self.success = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype42, _size39) = iprot.readListBegin()
          for _i43 in xrange(_size39):
            _elem44 = column_t()
            _elem44.read(iprot)
            self.success.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter45 in self.success:
        iter45.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_column_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.tablename = None
    self.key = None
    self.columnFamily_column = None
    if isinstance(d, dict):
      if 'tablename' in d:
        self.tablename = d['tablename']
      if 'key' in d:
        self.key = d['key']
      if 'columnFamily_column' in d:
        self.columnFamily_column = d['columnFamily_column']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRING:
          self.columnFamily_column = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_column_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, -1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, -2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnFamily_column != None:
      oprot.writeFieldBegin('columnFamily_column', TType.STRING, -3)
      oprot.writeString(self.columnFamily_column)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_column_result:

  thrift_spec = (
    (0, TType.STRUCT, 'success', (column_t, column_t.thrift_spec), None, ), # 0
  )

  def __init__(self, d=None):
    self.success = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = column_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_column_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_column_count_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.tablename = None
    self.key = None
    self.columnFamily_column = None
    if isinstance(d, dict):
      if 'tablename' in d:
        self.tablename = d['tablename']
      if 'key' in d:
        self.key = d['key']
      if 'columnFamily_column' in d:
        self.columnFamily_column = d['columnFamily_column']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRING:
          self.columnFamily_column = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_column_count_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, -1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, -2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnFamily_column != None:
      oprot.writeFieldBegin('columnFamily_column', TType.STRING, -3)
      oprot.writeString(self.columnFamily_column)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_column_count_result:

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, d=None):
    self.success = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_column_count_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insert_blocking_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.tablename = None
    self.key = None
    self.columnFamily_column = None
    self.cellData = None
    self.timestamp = None
    if isinstance(d, dict):
      if 'tablename' in d:
        self.tablename = d['tablename']
      if 'key' in d:
        self.key = d['key']
      if 'columnFamily_column' in d:
        self.columnFamily_column = d['columnFamily_column']
      if 'cellData' in d:
        self.cellData = d['cellData']
      if 'timestamp' in d:
        self.timestamp = d['timestamp']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRING:
          self.columnFamily_column = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.STRING:
          self.cellData = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.I32:
          self.timestamp = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insert_blocking_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, -1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, -2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnFamily_column != None:
      oprot.writeFieldBegin('columnFamily_column', TType.STRING, -3)
      oprot.writeString(self.columnFamily_column)
      oprot.writeFieldEnd()
    if self.cellData != None:
      oprot.writeFieldBegin('cellData', TType.STRING, -4)
      oprot.writeString(self.cellData)
      oprot.writeFieldEnd()
    if self.timestamp != None:
      oprot.writeFieldBegin('timestamp', TType.I32, -5)
      oprot.writeI32(self.timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insert_blocking_result:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insert_blocking_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insert_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.tablename = None
    self.key = None
    self.columnFamily_column = None
    self.cellData = None
    self.timestamp = None
    if isinstance(d, dict):
      if 'tablename' in d:
        self.tablename = d['tablename']
      if 'key' in d:
        self.key = d['key']
      if 'columnFamily_column' in d:
        self.columnFamily_column = d['columnFamily_column']
      if 'cellData' in d:
        self.cellData = d['cellData']
      if 'timestamp' in d:
        self.timestamp = d['timestamp']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRING:
          self.columnFamily_column = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.STRING:
          self.cellData = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.I32:
          self.timestamp = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insert_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, -1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, -2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnFamily_column != None:
      oprot.writeFieldBegin('columnFamily_column', TType.STRING, -3)
      oprot.writeString(self.columnFamily_column)
      oprot.writeFieldEnd()
    if self.cellData != None:
      oprot.writeFieldBegin('cellData', TType.STRING, -4)
      oprot.writeString(self.cellData)
      oprot.writeFieldEnd()
    if self.timestamp != None:
      oprot.writeFieldBegin('timestamp', TType.I32, -5)
      oprot.writeI32(self.timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insert_result:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insert_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_insert_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.batchMutation = None
    if isinstance(d, dict):
      if 'batchMutation' in d:
        self.batchMutation = d['batchMutation']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.batchMutation = batch_mutation_t()
          self.batchMutation.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_insert_args')
    if self.batchMutation != None:
      oprot.writeFieldBegin('batchMutation', TType.STRUCT, -1)
      self.batchMutation.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_insert_result:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_insert_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_insert_blocking_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.batchMutation = None
    if isinstance(d, dict):
      if 'batchMutation' in d:
        self.batchMutation = d['batchMutation']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.batchMutation = batch_mutation_t()
          self.batchMutation.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_insert_blocking_args')
    if self.batchMutation != None:
      oprot.writeFieldBegin('batchMutation', TType.STRUCT, -1)
      self.batchMutation.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_insert_blocking_result:

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, d=None):
    self.success = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_insert_blocking_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.tablename = None
    self.key = None
    self.columnFamily_column = None
    if isinstance(d, dict):
      if 'tablename' in d:
        self.tablename = d['tablename']
      if 'key' in d:
        self.key = d['key']
      if 'columnFamily_column' in d:
        self.columnFamily_column = d['columnFamily_column']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRING:
          self.columnFamily_column = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, -1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, -2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnFamily_column != None:
      oprot.writeFieldBegin('columnFamily_column', TType.STRING, -3)
      oprot.writeString(self.columnFamily_column)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_result:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_super_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.tablename = None
    self.key = None
    self.columnFamily_superColumnName = None
    self.start = -1
    self.count = -1
    if isinstance(d, dict):
      if 'tablename' in d:
        self.tablename = d['tablename']
      if 'key' in d:
        self.key = d['key']
      if 'columnFamily_superColumnName' in d:
        self.columnFamily_superColumnName = d['columnFamily_superColumnName']
      if 'start' in d:
        self.start = d['start']
      if 'count' in d:
        self.count = d['count']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRING:
          self.columnFamily_superColumnName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.I32:
          self.start = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_super_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, -1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, -2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnFamily_superColumnName != None:
      oprot.writeFieldBegin('columnFamily_superColumnName', TType.STRING, -3)
      oprot.writeString(self.columnFamily_superColumnName)
      oprot.writeFieldEnd()
    if self.start != None:
      oprot.writeFieldBegin('start', TType.I32, -4)
      oprot.writeI32(self.start)
      oprot.writeFieldEnd()
    if self.count != None:
      oprot.writeFieldBegin('count', TType.I32, -5)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_super_result:

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(superColumn_t, superColumn_t.thrift_spec)), None, ), # 0
  )

  def __init__(self, d=None):
    self.success = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype49, _size46) = iprot.readListBegin()
          for _i50 in xrange(_size46):
            _elem51 = superColumn_t()
            _elem51.read(iprot)
            self.success.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_super_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter52 in self.success:
        iter52.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_superColumn_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.tablename = None
    self.key = None
    self.columnFamily = None
    if isinstance(d, dict):
      if 'tablename' in d:
        self.tablename = d['tablename']
      if 'key' in d:
        self.key = d['key']
      if 'columnFamily' in d:
        self.columnFamily = d['columnFamily']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRING:
          self.columnFamily = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_superColumn_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, -1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, -2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnFamily != None:
      oprot.writeFieldBegin('columnFamily', TType.STRING, -3)
      oprot.writeString(self.columnFamily)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_superColumn_result:

  thrift_spec = (
    (0, TType.STRUCT, 'success', (superColumn_t, superColumn_t.thrift_spec), None, ), # 0
  )

  def __init__(self, d=None):
    self.success = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = superColumn_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_superColumn_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_insert_superColumn_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.batchMutationSuper = None
    if isinstance(d, dict):
      if 'batchMutationSuper' in d:
        self.batchMutationSuper = d['batchMutationSuper']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.batchMutationSuper = batch_mutation_super_t()
          self.batchMutationSuper.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_insert_superColumn_args')
    if self.batchMutationSuper != None:
      oprot.writeFieldBegin('batchMutationSuper', TType.STRUCT, -1)
      self.batchMutationSuper.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_insert_superColumn_result:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_insert_superColumn_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_insert_superColumn_blocking_args:

  thrift_spec = None
  def __init__(self, d=None):
    self.batchMutationSuper = None
    if isinstance(d, dict):
      if 'batchMutationSuper' in d:
        self.batchMutationSuper = d['batchMutationSuper']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.batchMutationSuper = batch_mutation_super_t()
          self.batchMutationSuper.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_insert_superColumn_blocking_args')
    if self.batchMutationSuper != None:
      oprot.writeFieldBegin('batchMutationSuper', TType.STRUCT, -1)
      self.batchMutationSuper.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_insert_superColumn_blocking_result:

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, d=None):
    self.success = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_insert_superColumn_blocking_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


