(*
 Autogenerated by Thrift

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
open Cassandra_types

(* HELPER FUNCTIONS AND STRUCTURES *)

class get_slice_args =
object (self)
  val mutable _tablename : string option = None
  method get_tablename = _tablename
  method grab_tablename = match _tablename with None->raise (Field_empty "get_slice_args.tablename") | Some _x60 -> _x60
  method set_tablename _x60 = _tablename <- Some _x60
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_slice_args.key") | Some _x60 -> _x60
  method set_key _x60 = _key <- Some _x60
  val mutable _columnFamily_column : string option = None
  method get_columnFamily_column = _columnFamily_column
  method grab_columnFamily_column = match _columnFamily_column with None->raise (Field_empty "get_slice_args.columnFamily_column") | Some _x60 -> _x60
  method set_columnFamily_column _x60 = _columnFamily_column <- Some _x60
  val mutable _start : int option = None
  method get_start = _start
  method grab_start = match _start with None->raise (Field_empty "get_slice_args.start") | Some _x60 -> _x60
  method set_start _x60 = _start <- Some _x60
  val mutable _count : int option = None
  method get_count = _count
  method grab_count = match _count with None->raise (Field_empty "get_slice_args.count") | Some _x60 -> _x60
  method set_count _x60 = _count <- Some _x60
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_args";
    (match _tablename with None -> () | Some _v -> 
      oprot#writeFieldBegin("tablename",Protocol.T_STRING,-1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,-2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columnFamily_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("columnFamily_column",Protocol.T_STRING,-3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _start with None -> () | Some _v -> 
      oprot#writeFieldBegin("start",Protocol.T_I32,-4);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _count with None -> () | Some _v -> 
      oprot#writeFieldBegin("count",Protocol.T_I32,-5);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_args (iprot : Protocol.t) =
  let _str63 = new get_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t64,_id65) = iprot#readFieldBegin in
        if _t64 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id65 with 
          | -1 -> (if _t64 = Protocol.T_STRING then
              _str63#set_tablename iprot#readString
            else
              iprot#skip _t64)
          | -2 -> (if _t64 = Protocol.T_STRING then
              _str63#set_key iprot#readString
            else
              iprot#skip _t64)
          | -3 -> (if _t64 = Protocol.T_STRING then
              _str63#set_columnFamily_column iprot#readString
            else
              iprot#skip _t64)
          | -4 -> (if _t64 = Protocol.T_I32 then
              _str63#set_start iprot#readI32
            else
              iprot#skip _t64)
          | -5 -> (if _t64 = Protocol.T_I32 then
              _str63#set_count iprot#readI32
            else
              iprot#skip _t64)
          | _ -> iprot#skip _t64);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str63

class get_slice_result =
object (self)
  val mutable _success : column_t list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_slice_result.success") | Some _x66 -> _x66
  method set_success _x66 = _success <- Some _x66
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter69 ->         _iter69#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_result (iprot : Protocol.t) =
  let _str70 = new get_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t71,_id72) = iprot#readFieldBegin in
        if _t71 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id72 with 
          | 0 -> (if _t71 = Protocol.T_LIST then
              _str70#set_success 
                (let (_etype76,_size73) = iprot#readListBegin in
                  let _con77 = (Array.to_list (Array.init _size73 (fun _ -> (read_column_t iprot)))) in
                    iprot#readListEnd; _con77)
            else
              iprot#skip _t71)
          | _ -> iprot#skip _t71);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str70

class get_column_args =
object (self)
  val mutable _tablename : string option = None
  method get_tablename = _tablename
  method grab_tablename = match _tablename with None->raise (Field_empty "get_column_args.tablename") | Some _x78 -> _x78
  method set_tablename _x78 = _tablename <- Some _x78
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_column_args.key") | Some _x78 -> _x78
  method set_key _x78 = _key <- Some _x78
  val mutable _columnFamily_column : string option = None
  method get_columnFamily_column = _columnFamily_column
  method grab_columnFamily_column = match _columnFamily_column with None->raise (Field_empty "get_column_args.columnFamily_column") | Some _x78 -> _x78
  method set_columnFamily_column _x78 = _columnFamily_column <- Some _x78
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_column_args";
    (match _tablename with None -> () | Some _v -> 
      oprot#writeFieldBegin("tablename",Protocol.T_STRING,-1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,-2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columnFamily_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("columnFamily_column",Protocol.T_STRING,-3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_column_args (iprot : Protocol.t) =
  let _str81 = new get_column_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t82,_id83) = iprot#readFieldBegin in
        if _t82 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id83 with 
          | -1 -> (if _t82 = Protocol.T_STRING then
              _str81#set_tablename iprot#readString
            else
              iprot#skip _t82)
          | -2 -> (if _t82 = Protocol.T_STRING then
              _str81#set_key iprot#readString
            else
              iprot#skip _t82)
          | -3 -> (if _t82 = Protocol.T_STRING then
              _str81#set_columnFamily_column iprot#readString
            else
              iprot#skip _t82)
          | _ -> iprot#skip _t82);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str81

class get_column_result =
object (self)
  val mutable _success : column_t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_column_result.success") | Some _x84 -> _x84
  method set_success _x84 = _success <- Some _x84
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_column_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_column_result (iprot : Protocol.t) =
  let _str87 = new get_column_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t88,_id89) = iprot#readFieldBegin in
        if _t88 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id89 with 
          | 0 -> (if _t88 = Protocol.T_STRUCT then
              _str87#set_success (read_column_t iprot)
            else
              iprot#skip _t88)
          | _ -> iprot#skip _t88);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str87

class get_column_count_args =
object (self)
  val mutable _tablename : string option = None
  method get_tablename = _tablename
  method grab_tablename = match _tablename with None->raise (Field_empty "get_column_count_args.tablename") | Some _x90 -> _x90
  method set_tablename _x90 = _tablename <- Some _x90
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_column_count_args.key") | Some _x90 -> _x90
  method set_key _x90 = _key <- Some _x90
  val mutable _columnFamily_column : string option = None
  method get_columnFamily_column = _columnFamily_column
  method grab_columnFamily_column = match _columnFamily_column with None->raise (Field_empty "get_column_count_args.columnFamily_column") | Some _x90 -> _x90
  method set_columnFamily_column _x90 = _columnFamily_column <- Some _x90
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_column_count_args";
    (match _tablename with None -> () | Some _v -> 
      oprot#writeFieldBegin("tablename",Protocol.T_STRING,-1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,-2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columnFamily_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("columnFamily_column",Protocol.T_STRING,-3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_column_count_args (iprot : Protocol.t) =
  let _str93 = new get_column_count_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t94,_id95) = iprot#readFieldBegin in
        if _t94 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id95 with 
          | -1 -> (if _t94 = Protocol.T_STRING then
              _str93#set_tablename iprot#readString
            else
              iprot#skip _t94)
          | -2 -> (if _t94 = Protocol.T_STRING then
              _str93#set_key iprot#readString
            else
              iprot#skip _t94)
          | -3 -> (if _t94 = Protocol.T_STRING then
              _str93#set_columnFamily_column iprot#readString
            else
              iprot#skip _t94)
          | _ -> iprot#skip _t94);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str93

class get_column_count_result =
object (self)
  val mutable _success : int option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_column_count_result.success") | Some _x96 -> _x96
  method set_success _x96 = _success <- Some _x96
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_column_count_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_I32,0);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_column_count_result (iprot : Protocol.t) =
  let _str99 = new get_column_count_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t100,_id101) = iprot#readFieldBegin in
        if _t100 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id101 with 
          | 0 -> (if _t100 = Protocol.T_I32 then
              _str99#set_success iprot#readI32
            else
              iprot#skip _t100)
          | _ -> iprot#skip _t100);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str99

class insert_args =
object (self)
  val mutable _tablename : string option = None
  method get_tablename = _tablename
  method grab_tablename = match _tablename with None->raise (Field_empty "insert_args.tablename") | Some _x102 -> _x102
  method set_tablename _x102 = _tablename <- Some _x102
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "insert_args.key") | Some _x102 -> _x102
  method set_key _x102 = _key <- Some _x102
  val mutable _columnFamily_column : string option = None
  method get_columnFamily_column = _columnFamily_column
  method grab_columnFamily_column = match _columnFamily_column with None->raise (Field_empty "insert_args.columnFamily_column") | Some _x102 -> _x102
  method set_columnFamily_column _x102 = _columnFamily_column <- Some _x102
  val mutable _cellData : string option = None
  method get_cellData = _cellData
  method grab_cellData = match _cellData with None->raise (Field_empty "insert_args.cellData") | Some _x102 -> _x102
  method set_cellData _x102 = _cellData <- Some _x102
  val mutable _timestamp : int option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "insert_args.timestamp") | Some _x102 -> _x102
  method set_timestamp _x102 = _timestamp <- Some _x102
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_args";
    (match _tablename with None -> () | Some _v -> 
      oprot#writeFieldBegin("tablename",Protocol.T_STRING,-1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,-2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columnFamily_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("columnFamily_column",Protocol.T_STRING,-3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _cellData with None -> () | Some _v -> 
      oprot#writeFieldBegin("cellData",Protocol.T_STRING,-4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _timestamp with None -> () | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I32,-5);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_args (iprot : Protocol.t) =
  let _str105 = new insert_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t106,_id107) = iprot#readFieldBegin in
        if _t106 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id107 with 
          | -1 -> (if _t106 = Protocol.T_STRING then
              _str105#set_tablename iprot#readString
            else
              iprot#skip _t106)
          | -2 -> (if _t106 = Protocol.T_STRING then
              _str105#set_key iprot#readString
            else
              iprot#skip _t106)
          | -3 -> (if _t106 = Protocol.T_STRING then
              _str105#set_columnFamily_column iprot#readString
            else
              iprot#skip _t106)
          | -4 -> (if _t106 = Protocol.T_STRING then
              _str105#set_cellData iprot#readString
            else
              iprot#skip _t106)
          | -5 -> (if _t106 = Protocol.T_I32 then
              _str105#set_timestamp iprot#readI32
            else
              iprot#skip _t106)
          | _ -> iprot#skip _t106);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str105

class insert_result =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_result";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_result (iprot : Protocol.t) =
  let _str111 = new insert_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t112,_id113) = iprot#readFieldBegin in
        if _t112 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id113 with 
          | _ -> iprot#skip _t112);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str111

class batch_insert_args =
object (self)
  val mutable _batchMutation : batch_mutation_t option = None
  method get_batchMutation = _batchMutation
  method grab_batchMutation = match _batchMutation with None->raise (Field_empty "batch_insert_args.batchMutation") | Some _x114 -> _x114
  method set_batchMutation _x114 = _batchMutation <- Some _x114
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_insert_args";
    (match _batchMutation with None -> () | Some _v -> 
      oprot#writeFieldBegin("batchMutation",Protocol.T_STRUCT,-1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_insert_args (iprot : Protocol.t) =
  let _str117 = new batch_insert_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t118,_id119) = iprot#readFieldBegin in
        if _t118 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id119 with 
          | -1 -> (if _t118 = Protocol.T_STRUCT then
              _str117#set_batchMutation (read_batch_mutation_t iprot)
            else
              iprot#skip _t118)
          | _ -> iprot#skip _t118);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str117

class batch_insert_result =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_insert_result";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_insert_result (iprot : Protocol.t) =
  let _str123 = new batch_insert_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t124,_id125) = iprot#readFieldBegin in
        if _t124 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id125 with 
          | _ -> iprot#skip _t124);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str123

class batch_insert_blocking_args =
object (self)
  val mutable _batchMutation : batch_mutation_t option = None
  method get_batchMutation = _batchMutation
  method grab_batchMutation = match _batchMutation with None->raise (Field_empty "batch_insert_blocking_args.batchMutation") | Some _x126 -> _x126
  method set_batchMutation _x126 = _batchMutation <- Some _x126
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_insert_blocking_args";
    (match _batchMutation with None -> () | Some _v -> 
      oprot#writeFieldBegin("batchMutation",Protocol.T_STRUCT,-1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_insert_blocking_args (iprot : Protocol.t) =
  let _str129 = new batch_insert_blocking_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t130,_id131) = iprot#readFieldBegin in
        if _t130 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id131 with 
          | -1 -> (if _t130 = Protocol.T_STRUCT then
              _str129#set_batchMutation (read_batch_mutation_t iprot)
            else
              iprot#skip _t130)
          | _ -> iprot#skip _t130);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str129

class batch_insert_blocking_result =
object (self)
  val mutable _success : bool option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "batch_insert_blocking_result.success") | Some _x132 -> _x132
  method set_success _x132 = _success <- Some _x132
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_insert_blocking_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_BOOL,0);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_insert_blocking_result (iprot : Protocol.t) =
  let _str135 = new batch_insert_blocking_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t136,_id137) = iprot#readFieldBegin in
        if _t136 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id137 with 
          | 0 -> (if _t136 = Protocol.T_BOOL then
              _str135#set_success iprot#readBool
            else
              iprot#skip _t136)
          | _ -> iprot#skip _t136);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str135

class remove_args =
object (self)
  val mutable _tablename : string option = None
  method get_tablename = _tablename
  method grab_tablename = match _tablename with None->raise (Field_empty "remove_args.tablename") | Some _x138 -> _x138
  method set_tablename _x138 = _tablename <- Some _x138
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "remove_args.key") | Some _x138 -> _x138
  method set_key _x138 = _key <- Some _x138
  val mutable _columnFamily_column : string option = None
  method get_columnFamily_column = _columnFamily_column
  method grab_columnFamily_column = match _columnFamily_column with None->raise (Field_empty "remove_args.columnFamily_column") | Some _x138 -> _x138
  method set_columnFamily_column _x138 = _columnFamily_column <- Some _x138
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_args";
    (match _tablename with None -> () | Some _v -> 
      oprot#writeFieldBegin("tablename",Protocol.T_STRING,-1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,-2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columnFamily_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("columnFamily_column",Protocol.T_STRING,-3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_args (iprot : Protocol.t) =
  let _str141 = new remove_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t142,_id143) = iprot#readFieldBegin in
        if _t142 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id143 with 
          | -1 -> (if _t142 = Protocol.T_STRING then
              _str141#set_tablename iprot#readString
            else
              iprot#skip _t142)
          | -2 -> (if _t142 = Protocol.T_STRING then
              _str141#set_key iprot#readString
            else
              iprot#skip _t142)
          | -3 -> (if _t142 = Protocol.T_STRING then
              _str141#set_columnFamily_column iprot#readString
            else
              iprot#skip _t142)
          | _ -> iprot#skip _t142);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str141

class remove_result =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_result";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_result (iprot : Protocol.t) =
  let _str147 = new remove_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t148,_id149) = iprot#readFieldBegin in
        if _t148 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id149 with 
          | _ -> iprot#skip _t148);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str147

class get_slice_super_args =
object (self)
  val mutable _tablename : string option = None
  method get_tablename = _tablename
  method grab_tablename = match _tablename with None->raise (Field_empty "get_slice_super_args.tablename") | Some _x150 -> _x150
  method set_tablename _x150 = _tablename <- Some _x150
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_slice_super_args.key") | Some _x150 -> _x150
  method set_key _x150 = _key <- Some _x150
  val mutable _columnFamily_superColumnName : string option = None
  method get_columnFamily_superColumnName = _columnFamily_superColumnName
  method grab_columnFamily_superColumnName = match _columnFamily_superColumnName with None->raise (Field_empty "get_slice_super_args.columnFamily_superColumnName") | Some _x150 -> _x150
  method set_columnFamily_superColumnName _x150 = _columnFamily_superColumnName <- Some _x150
  val mutable _start : int option = None
  method get_start = _start
  method grab_start = match _start with None->raise (Field_empty "get_slice_super_args.start") | Some _x150 -> _x150
  method set_start _x150 = _start <- Some _x150
  val mutable _count : int option = None
  method get_count = _count
  method grab_count = match _count with None->raise (Field_empty "get_slice_super_args.count") | Some _x150 -> _x150
  method set_count _x150 = _count <- Some _x150
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_super_args";
    (match _tablename with None -> () | Some _v -> 
      oprot#writeFieldBegin("tablename",Protocol.T_STRING,-1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,-2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columnFamily_superColumnName with None -> () | Some _v -> 
      oprot#writeFieldBegin("columnFamily_superColumnName",Protocol.T_STRING,-3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _start with None -> () | Some _v -> 
      oprot#writeFieldBegin("start",Protocol.T_I32,-4);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _count with None -> () | Some _v -> 
      oprot#writeFieldBegin("count",Protocol.T_I32,-5);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_super_args (iprot : Protocol.t) =
  let _str153 = new get_slice_super_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t154,_id155) = iprot#readFieldBegin in
        if _t154 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id155 with 
          | -1 -> (if _t154 = Protocol.T_STRING then
              _str153#set_tablename iprot#readString
            else
              iprot#skip _t154)
          | -2 -> (if _t154 = Protocol.T_STRING then
              _str153#set_key iprot#readString
            else
              iprot#skip _t154)
          | -3 -> (if _t154 = Protocol.T_STRING then
              _str153#set_columnFamily_superColumnName iprot#readString
            else
              iprot#skip _t154)
          | -4 -> (if _t154 = Protocol.T_I32 then
              _str153#set_start iprot#readI32
            else
              iprot#skip _t154)
          | -5 -> (if _t154 = Protocol.T_I32 then
              _str153#set_count iprot#readI32
            else
              iprot#skip _t154)
          | _ -> iprot#skip _t154);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str153

class get_slice_super_result =
object (self)
  val mutable _success : superColumn_t list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_slice_super_result.success") | Some _x156 -> _x156
  method set_success _x156 = _success <- Some _x156
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_super_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter159 ->         _iter159#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_super_result (iprot : Protocol.t) =
  let _str160 = new get_slice_super_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t161,_id162) = iprot#readFieldBegin in
        if _t161 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id162 with 
          | 0 -> (if _t161 = Protocol.T_LIST then
              _str160#set_success 
                (let (_etype166,_size163) = iprot#readListBegin in
                  let _con167 = (Array.to_list (Array.init _size163 (fun _ -> (read_superColumn_t iprot)))) in
                    iprot#readListEnd; _con167)
            else
              iprot#skip _t161)
          | _ -> iprot#skip _t161);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str160

class get_superColumn_args =
object (self)
  val mutable _tablename : string option = None
  method get_tablename = _tablename
  method grab_tablename = match _tablename with None->raise (Field_empty "get_superColumn_args.tablename") | Some _x168 -> _x168
  method set_tablename _x168 = _tablename <- Some _x168
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_superColumn_args.key") | Some _x168 -> _x168
  method set_key _x168 = _key <- Some _x168
  val mutable _columnFamily : string option = None
  method get_columnFamily = _columnFamily
  method grab_columnFamily = match _columnFamily with None->raise (Field_empty "get_superColumn_args.columnFamily") | Some _x168 -> _x168
  method set_columnFamily _x168 = _columnFamily <- Some _x168
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_superColumn_args";
    (match _tablename with None -> () | Some _v -> 
      oprot#writeFieldBegin("tablename",Protocol.T_STRING,-1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,-2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columnFamily with None -> () | Some _v -> 
      oprot#writeFieldBegin("columnFamily",Protocol.T_STRING,-3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_superColumn_args (iprot : Protocol.t) =
  let _str171 = new get_superColumn_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t172,_id173) = iprot#readFieldBegin in
        if _t172 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id173 with 
          | -1 -> (if _t172 = Protocol.T_STRING then
              _str171#set_tablename iprot#readString
            else
              iprot#skip _t172)
          | -2 -> (if _t172 = Protocol.T_STRING then
              _str171#set_key iprot#readString
            else
              iprot#skip _t172)
          | -3 -> (if _t172 = Protocol.T_STRING then
              _str171#set_columnFamily iprot#readString
            else
              iprot#skip _t172)
          | _ -> iprot#skip _t172);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str171

class get_superColumn_result =
object (self)
  val mutable _success : superColumn_t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_superColumn_result.success") | Some _x174 -> _x174
  method set_success _x174 = _success <- Some _x174
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_superColumn_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_superColumn_result (iprot : Protocol.t) =
  let _str177 = new get_superColumn_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t178,_id179) = iprot#readFieldBegin in
        if _t178 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id179 with 
          | 0 -> (if _t178 = Protocol.T_STRUCT then
              _str177#set_success (read_superColumn_t iprot)
            else
              iprot#skip _t178)
          | _ -> iprot#skip _t178);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str177

class batch_insert_superColumn_args =
object (self)
  val mutable _batchMutationSuper : batch_mutation_super_t option = None
  method get_batchMutationSuper = _batchMutationSuper
  method grab_batchMutationSuper = match _batchMutationSuper with None->raise (Field_empty "batch_insert_superColumn_args.batchMutationSuper") | Some _x180 -> _x180
  method set_batchMutationSuper _x180 = _batchMutationSuper <- Some _x180
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_insert_superColumn_args";
    (match _batchMutationSuper with None -> () | Some _v -> 
      oprot#writeFieldBegin("batchMutationSuper",Protocol.T_STRUCT,-1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_insert_superColumn_args (iprot : Protocol.t) =
  let _str183 = new batch_insert_superColumn_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t184,_id185) = iprot#readFieldBegin in
        if _t184 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id185 with 
          | -1 -> (if _t184 = Protocol.T_STRUCT then
              _str183#set_batchMutationSuper (read_batch_mutation_super_t iprot)
            else
              iprot#skip _t184)
          | _ -> iprot#skip _t184);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str183

class batch_insert_superColumn_result =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_insert_superColumn_result";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_insert_superColumn_result (iprot : Protocol.t) =
  let _str189 = new batch_insert_superColumn_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t190,_id191) = iprot#readFieldBegin in
        if _t190 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id191 with 
          | _ -> iprot#skip _t190);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str189

class batch_insert_superColumn_blocking_args =
object (self)
  val mutable _batchMutationSuper : batch_mutation_super_t option = None
  method get_batchMutationSuper = _batchMutationSuper
  method grab_batchMutationSuper = match _batchMutationSuper with None->raise (Field_empty "batch_insert_superColumn_blocking_args.batchMutationSuper") | Some _x192 -> _x192
  method set_batchMutationSuper _x192 = _batchMutationSuper <- Some _x192
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_insert_superColumn_blocking_args";
    (match _batchMutationSuper with None -> () | Some _v -> 
      oprot#writeFieldBegin("batchMutationSuper",Protocol.T_STRUCT,-1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_insert_superColumn_blocking_args (iprot : Protocol.t) =
  let _str195 = new batch_insert_superColumn_blocking_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t196,_id197) = iprot#readFieldBegin in
        if _t196 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id197 with 
          | -1 -> (if _t196 = Protocol.T_STRUCT then
              _str195#set_batchMutationSuper (read_batch_mutation_super_t iprot)
            else
              iprot#skip _t196)
          | _ -> iprot#skip _t196);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str195

class batch_insert_superColumn_blocking_result =
object (self)
  val mutable _success : bool option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "batch_insert_superColumn_blocking_result.success") | Some _x198 -> _x198
  method set_success _x198 = _success <- Some _x198
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_insert_superColumn_blocking_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_BOOL,0);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_insert_superColumn_blocking_result (iprot : Protocol.t) =
  let _str201 = new batch_insert_superColumn_blocking_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t202,_id203) = iprot#readFieldBegin in
        if _t202 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id203 with 
          | 0 -> (if _t202 = Protocol.T_BOOL then
              _str201#set_success iprot#readBool
            else
              iprot#skip _t202)
          | _ -> iprot#skip _t202);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str201

class virtual iface =
object (self)
  inherit FacebookService.iface
  method virtual get_slice : string option -> string option -> string option -> int option -> int option -> column_t list
  method virtual get_column : string option -> string option -> string option -> column_t
  method virtual get_column_count : string option -> string option -> string option -> int
  method virtual insert : string option -> string option -> string option -> string option -> int option -> unit
  method virtual batch_insert : batch_mutation_t option -> unit
  method virtual batch_insert_blocking : batch_mutation_t option -> bool
  method virtual remove : string option -> string option -> string option -> unit
  method virtual get_slice_super : string option -> string option -> string option -> int option -> int option -> superColumn_t list
  method virtual get_superColumn : string option -> string option -> string option -> superColumn_t
  method virtual batch_insert_superColumn : batch_mutation_super_t option -> unit
  method virtual batch_insert_superColumn_blocking : batch_mutation_super_t option -> bool
end

class client (iprot : Protocol.t) (oprot : Protocol.t) =
object (self)
  inherit FacebookService.client iprot oprot as super
  val mutable seqid = 0
  method get_slice tablename key columnFamily_column start count = 
    self#send_get_slice tablename key columnFamily_column start count;
    self#recv_get_slice
  method private send_get_slice tablename key columnFamily_column start count = 
    oprot#writeMessageBegin ("get_slice", Protocol.CALL, seqid);
    let args = new get_slice_args in
      args#set_tablename tablename;
      args#set_key key;
      args#set_columnFamily_column columnFamily_column;
      args#set_start start;
      args#set_count count;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_slice failed: unknown result")))
  method get_column tablename key columnFamily_column = 
    self#send_get_column tablename key columnFamily_column;
    self#recv_get_column
  method private send_get_column tablename key columnFamily_column = 
    oprot#writeMessageBegin ("get_column", Protocol.CALL, seqid);
    let args = new get_column_args in
      args#set_tablename tablename;
      args#set_key key;
      args#set_columnFamily_column columnFamily_column;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_column  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_column_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_column failed: unknown result")))
  method get_column_count tablename key columnFamily_column = 
    self#send_get_column_count tablename key columnFamily_column;
    self#recv_get_column_count
  method private send_get_column_count tablename key columnFamily_column = 
    oprot#writeMessageBegin ("get_column_count", Protocol.CALL, seqid);
    let args = new get_column_count_args in
      args#set_tablename tablename;
      args#set_key key;
      args#set_columnFamily_column columnFamily_column;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_column_count  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_column_count_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_column_count failed: unknown result")))
  method insert tablename key columnFamily_column cellData timestamp = 
    self#send_insert tablename key columnFamily_column cellData timestamp;
  method private send_insert tablename key columnFamily_column cellData timestamp = 
    oprot#writeMessageBegin ("insert", Protocol.CALL, seqid);
    let args = new insert_args in
      args#set_tablename tablename;
      args#set_key key;
      args#set_columnFamily_column columnFamily_column;
      args#set_cellData cellData;
      args#set_timestamp timestamp;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method batch_insert batchMutation = 
    self#send_batch_insert batchMutation;
  method private send_batch_insert batchMutation = 
    oprot#writeMessageBegin ("batch_insert", Protocol.CALL, seqid);
    let args = new batch_insert_args in
      args#set_batchMutation batchMutation;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method batch_insert_blocking batchMutation = 
    self#send_batch_insert_blocking batchMutation;
    self#recv_batch_insert_blocking
  method private send_batch_insert_blocking batchMutation = 
    oprot#writeMessageBegin ("batch_insert_blocking", Protocol.CALL, seqid);
    let args = new batch_insert_blocking_args in
      args#set_batchMutation batchMutation;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_batch_insert_blocking  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_batch_insert_blocking_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "batch_insert_blocking failed: unknown result")))
  method remove tablename key columnFamily_column = 
    self#send_remove tablename key columnFamily_column;
  method private send_remove tablename key columnFamily_column = 
    oprot#writeMessageBegin ("remove", Protocol.CALL, seqid);
    let args = new remove_args in
      args#set_tablename tablename;
      args#set_key key;
      args#set_columnFamily_column columnFamily_column;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method get_slice_super tablename key columnFamily_superColumnName start count = 
    self#send_get_slice_super tablename key columnFamily_superColumnName start count;
    self#recv_get_slice_super
  method private send_get_slice_super tablename key columnFamily_superColumnName start count = 
    oprot#writeMessageBegin ("get_slice_super", Protocol.CALL, seqid);
    let args = new get_slice_super_args in
      args#set_tablename tablename;
      args#set_key key;
      args#set_columnFamily_superColumnName columnFamily_superColumnName;
      args#set_start start;
      args#set_count count;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_slice_super  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_slice_super_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_slice_super failed: unknown result")))
  method get_superColumn tablename key columnFamily = 
    self#send_get_superColumn tablename key columnFamily;
    self#recv_get_superColumn
  method private send_get_superColumn tablename key columnFamily = 
    oprot#writeMessageBegin ("get_superColumn", Protocol.CALL, seqid);
    let args = new get_superColumn_args in
      args#set_tablename tablename;
      args#set_key key;
      args#set_columnFamily columnFamily;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_superColumn  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_superColumn_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_superColumn failed: unknown result")))
  method batch_insert_superColumn batchMutationSuper = 
    self#send_batch_insert_superColumn batchMutationSuper;
  method private send_batch_insert_superColumn batchMutationSuper = 
    oprot#writeMessageBegin ("batch_insert_superColumn", Protocol.CALL, seqid);
    let args = new batch_insert_superColumn_args in
      args#set_batchMutationSuper batchMutationSuper;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method batch_insert_superColumn_blocking batchMutationSuper = 
    self#send_batch_insert_superColumn_blocking batchMutationSuper;
    self#recv_batch_insert_superColumn_blocking
  method private send_batch_insert_superColumn_blocking batchMutationSuper = 
    oprot#writeMessageBegin ("batch_insert_superColumn_blocking", Protocol.CALL, seqid);
    let args = new batch_insert_superColumn_blocking_args in
      args#set_batchMutationSuper batchMutationSuper;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_batch_insert_superColumn_blocking  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_batch_insert_superColumn_blocking_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "batch_insert_superColumn_blocking failed: unknown result")))
end

class processor (handler : iface) =
object (self)
  inherit Processor.t

  inherit FacebookService.processor (handler :> FacebookService.iface)
  method process iprot oprot =
    let (name, typ, seqid)  = iprot#readMessageBegin in
      if Hashtbl.mem processMap name then
        (Hashtbl.find processMap name) (seqid, iprot, oprot)
      else (
        iprot#skip(Protocol.T_STRUCT);
        iprot#readMessageEnd;
        let x = Application_Exn.create Application_Exn.UNKNOWN_METHOD ("Unknown function "^name) in
          oprot#writeMessageBegin(name, Protocol.EXCEPTION, seqid);
          x#write oprot;
          oprot#writeMessageEnd;
          oprot#getTransport#flush
      );
      true
  method private process_get_slice (seqid, iprot, oprot) =
    let args = read_get_slice_args iprot in
      iprot#readMessageEnd;
      let result = new get_slice_result in
        result#set_success (handler#get_slice args#get_tablename args#get_key args#get_columnFamily_column args#get_start args#get_count);
        oprot#writeMessageBegin ("get_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_column (seqid, iprot, oprot) =
    let args = read_get_column_args iprot in
      iprot#readMessageEnd;
      let result = new get_column_result in
        result#set_success (handler#get_column args#get_tablename args#get_key args#get_columnFamily_column);
        oprot#writeMessageBegin ("get_column", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_column_count (seqid, iprot, oprot) =
    let args = read_get_column_count_args iprot in
      iprot#readMessageEnd;
      let result = new get_column_count_result in
        result#set_success (handler#get_column_count args#get_tablename args#get_key args#get_columnFamily_column);
        oprot#writeMessageBegin ("get_column_count", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_insert (seqid, iprot, oprot) =
    let args = read_insert_args iprot in
      iprot#readMessageEnd;
      (handler#insert args#get_tablename args#get_key args#get_columnFamily_column args#get_cellData args#get_timestamp);
      ()
  method private process_batch_insert (seqid, iprot, oprot) =
    let args = read_batch_insert_args iprot in
      iprot#readMessageEnd;
      (handler#batch_insert args#get_batchMutation);
      ()
  method private process_batch_insert_blocking (seqid, iprot, oprot) =
    let args = read_batch_insert_blocking_args iprot in
      iprot#readMessageEnd;
      let result = new batch_insert_blocking_result in
        result#set_success (handler#batch_insert_blocking args#get_batchMutation);
        oprot#writeMessageBegin ("batch_insert_blocking", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_remove (seqid, iprot, oprot) =
    let args = read_remove_args iprot in
      iprot#readMessageEnd;
      (handler#remove args#get_tablename args#get_key args#get_columnFamily_column);
      ()
  method private process_get_slice_super (seqid, iprot, oprot) =
    let args = read_get_slice_super_args iprot in
      iprot#readMessageEnd;
      let result = new get_slice_super_result in
        result#set_success (handler#get_slice_super args#get_tablename args#get_key args#get_columnFamily_superColumnName args#get_start args#get_count);
        oprot#writeMessageBegin ("get_slice_super", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_superColumn (seqid, iprot, oprot) =
    let args = read_get_superColumn_args iprot in
      iprot#readMessageEnd;
      let result = new get_superColumn_result in
        result#set_success (handler#get_superColumn args#get_tablename args#get_key args#get_columnFamily);
        oprot#writeMessageBegin ("get_superColumn", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_batch_insert_superColumn (seqid, iprot, oprot) =
    let args = read_batch_insert_superColumn_args iprot in
      iprot#readMessageEnd;
      (handler#batch_insert_superColumn args#get_batchMutationSuper);
      ()
  method private process_batch_insert_superColumn_blocking (seqid, iprot, oprot) =
    let args = read_batch_insert_superColumn_blocking_args iprot in
      iprot#readMessageEnd;
      let result = new batch_insert_superColumn_blocking_result in
        result#set_success (handler#batch_insert_superColumn_blocking args#get_batchMutationSuper);
        oprot#writeMessageBegin ("batch_insert_superColumn_blocking", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  initializer
    Hashtbl.add processMap "get_slice" self#process_get_slice;
    Hashtbl.add processMap "get_column" self#process_get_column;
    Hashtbl.add processMap "get_column_count" self#process_get_column_count;
    Hashtbl.add processMap "insert" self#process_insert;
    Hashtbl.add processMap "batch_insert" self#process_batch_insert;
    Hashtbl.add processMap "batch_insert_blocking" self#process_batch_insert_blocking;
    Hashtbl.add processMap "remove" self#process_remove;
    Hashtbl.add processMap "get_slice_super" self#process_get_slice_super;
    Hashtbl.add processMap "get_superColumn" self#process_get_superColumn;
    Hashtbl.add processMap "batch_insert_superColumn" self#process_batch_insert_superColumn;
    Hashtbl.add processMap "batch_insert_superColumn_blocking" self#process_batch_insert_superColumn_blocking;
end

