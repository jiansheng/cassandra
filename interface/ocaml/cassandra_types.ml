(*
 Autogenerated by Thrift

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
class column_t =
object (self)
  val mutable _columnName : string option = None
  method get_columnName = _columnName
  method grab_columnName = match _columnName with None->raise (Field_empty "column_t.columnName") | Some _x0 -> _x0
  method set_columnName _x0 = _columnName <- Some _x0
  val mutable _value : string option = None
  method get_value = _value
  method grab_value = match _value with None->raise (Field_empty "column_t.value") | Some _x0 -> _x0
  method set_value _x0 = _value <- Some _x0
  val mutable _timestamp : int option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "column_t.timestamp") | Some _x0 -> _x0
  method set_timestamp _x0 = _timestamp <- Some _x0
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "column_t";
    (match _columnName with None -> () | Some _v -> 
      oprot#writeFieldBegin("columnName",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _value with None -> () | Some _v -> 
      oprot#writeFieldBegin("value",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _timestamp with None -> () | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I32,3);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_column_t (iprot : Protocol.t) =
  let _str3 = new column_t in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t4,_id5) = iprot#readFieldBegin in
        if _t4 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id5 with 
          | 1 -> (if _t4 = Protocol.T_STRING then
              _str3#set_columnName iprot#readString
            else
              iprot#skip _t4)
          | 2 -> (if _t4 = Protocol.T_STRING then
              _str3#set_value iprot#readString
            else
              iprot#skip _t4)
          | 3 -> (if _t4 = Protocol.T_I32 then
              _str3#set_timestamp iprot#readI32
            else
              iprot#skip _t4)
          | _ -> iprot#skip _t4);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str3

class batch_mutation_t =
object (self)
  val mutable _table : string option = None
  method get_table = _table
  method grab_table = match _table with None->raise (Field_empty "batch_mutation_t.table") | Some _x7 -> _x7
  method set_table _x7 = _table <- Some _x7
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "batch_mutation_t.key") | Some _x7 -> _x7
  method set_key _x7 = _key <- Some _x7
  val mutable _cfmap : (string,column_t list) Hashtbl.t option = None
  method get_cfmap = _cfmap
  method grab_cfmap = match _cfmap with None->raise (Field_empty "batch_mutation_t.cfmap") | Some _x7 -> _x7
  method set_cfmap _x7 = _cfmap <- Some _x7
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_mutation_t";
    (match _table with None -> () | Some _v -> 
      oprot#writeFieldBegin("table",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _cfmap with None -> () | Some _v -> 
      oprot#writeFieldBegin("cfmap",Protocol.T_MAP,3);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter10 -> fun _viter11 -> 
        oprot#writeString(_kiter10);
        oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter11);
        List.iter (fun _iter12 ->           _iter12#write(oprot);
        ) _viter11;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_mutation_t (iprot : Protocol.t) =
  let _str13 = new batch_mutation_t in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t14,_id15) = iprot#readFieldBegin in
        if _t14 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id15 with 
          | 1 -> (if _t14 = Protocol.T_STRING then
              _str13#set_table iprot#readString
            else
              iprot#skip _t14)
          | 2 -> (if _t14 = Protocol.T_STRING then
              _str13#set_key iprot#readString
            else
              iprot#skip _t14)
          | 3 -> (if _t14 = Protocol.T_MAP then
              _str13#set_cfmap 
                (let (_ktype17,_vtype18,_size16) = iprot#readMapBegin in
                let _con20 = Hashtbl.create _size16 in
                  for i = 1 to _size16 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype24,_size21) = iprot#readListBegin in
                        let _con25 = (Array.to_list (Array.init _size21 (fun _ -> (read_column_t iprot)))) in
                          iprot#readListEnd; _con25) in
                      Hashtbl.add _con20 _k _v
                  done; iprot#readMapEnd; _con20)
            else
              iprot#skip _t14)
          | _ -> iprot#skip _t14);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str13

class superColumn_t =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "superColumn_t.name") | Some _x27 -> _x27
  method set_name _x27 = _name <- Some _x27
  val mutable _columns : column_t list option = None
  method get_columns = _columns
  method grab_columns = match _columns with None->raise (Field_empty "superColumn_t.columns") | Some _x27 -> _x27
  method set_columns _x27 = _columns <- Some _x27
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "superColumn_t";
    (match _name with None -> () | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columns with None -> () | Some _v -> 
      oprot#writeFieldBegin("columns",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter30 ->         _iter30#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_superColumn_t (iprot : Protocol.t) =
  let _str31 = new superColumn_t in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t32,_id33) = iprot#readFieldBegin in
        if _t32 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id33 with 
          | 1 -> (if _t32 = Protocol.T_STRING then
              _str31#set_name iprot#readString
            else
              iprot#skip _t32)
          | 2 -> (if _t32 = Protocol.T_LIST then
              _str31#set_columns 
                (let (_etype37,_size34) = iprot#readListBegin in
                  let _con38 = (Array.to_list (Array.init _size34 (fun _ -> (read_column_t iprot)))) in
                    iprot#readListEnd; _con38)
            else
              iprot#skip _t32)
          | _ -> iprot#skip _t32);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str31

class batch_mutation_super_t =
object (self)
  val mutable _table : string option = None
  method get_table = _table
  method grab_table = match _table with None->raise (Field_empty "batch_mutation_super_t.table") | Some _x40 -> _x40
  method set_table _x40 = _table <- Some _x40
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "batch_mutation_super_t.key") | Some _x40 -> _x40
  method set_key _x40 = _key <- Some _x40
  val mutable _cfmap : (string,superColumn_t list) Hashtbl.t option = None
  method get_cfmap = _cfmap
  method grab_cfmap = match _cfmap with None->raise (Field_empty "batch_mutation_super_t.cfmap") | Some _x40 -> _x40
  method set_cfmap _x40 = _cfmap <- Some _x40
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_mutation_super_t";
    (match _table with None -> () | Some _v -> 
      oprot#writeFieldBegin("table",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _cfmap with None -> () | Some _v -> 
      oprot#writeFieldBegin("cfmap",Protocol.T_MAP,3);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter43 -> fun _viter44 -> 
        oprot#writeString(_kiter43);
        oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter44);
        List.iter (fun _iter45 ->           _iter45#write(oprot);
        ) _viter44;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_mutation_super_t (iprot : Protocol.t) =
  let _str46 = new batch_mutation_super_t in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t47,_id48) = iprot#readFieldBegin in
        if _t47 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id48 with 
          | 1 -> (if _t47 = Protocol.T_STRING then
              _str46#set_table iprot#readString
            else
              iprot#skip _t47)
          | 2 -> (if _t47 = Protocol.T_STRING then
              _str46#set_key iprot#readString
            else
              iprot#skip _t47)
          | 3 -> (if _t47 = Protocol.T_MAP then
              _str46#set_cfmap 
                (let (_ktype50,_vtype51,_size49) = iprot#readMapBegin in
                let _con53 = Hashtbl.create _size49 in
                  for i = 1 to _size49 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype57,_size54) = iprot#readListBegin in
                        let _con58 = (Array.to_list (Array.init _size54 (fun _ -> (read_superColumn_t iprot)))) in
                          iprot#readListEnd; _con58) in
                      Hashtbl.add _con53 _k _v
                  done; iprot#readMapEnd; _con53)
            else
              iprot#skip _t47)
          | _ -> iprot#skip _t47);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str46

type column_family_map = (string,column_t list) Hashtbl.t

type superColumn_family_map = (string,superColumn_t list) Hashtbl.t

