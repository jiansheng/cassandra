-----------------------------------------------------------------
-- Autogenerated by Thrift                                     --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Cassandra_Types where
import Thrift
import Data.Generics
import Control.Exception
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.Int
data Column_t = Column_t{f_Column_t_columnName :: Maybe ([Char]),f_Column_t_value :: Maybe ([Char]),f_Column_t_timestamp :: Maybe (Int)} deriving (Show,Eq,Ord,Typeable)
write_Column_t oprot rec = do
  writeStructBegin oprot "Column_t"
  case f_Column_t_columnName rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columnName",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_Column_t_value rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("value",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_Column_t_timestamp rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Column_t_fields iprot rec = do
  (_,_t3,_id4) <- readFieldBegin iprot
  if _t3 == T_STOP then return rec else
    case _id4 of 
      1 -> if _t3 == T_STRING then do
        s <- readString iprot
        read_Column_t_fields iprot rec{f_Column_t_columnName=Just s}
        else do
          skip iprot _t3
          read_Column_t_fields iprot rec
      2 -> if _t3 == T_STRING then do
        s <- readString iprot
        read_Column_t_fields iprot rec{f_Column_t_value=Just s}
        else do
          skip iprot _t3
          read_Column_t_fields iprot rec
      3 -> if _t3 == T_I32 then do
        s <- readI32 iprot
        read_Column_t_fields iprot rec{f_Column_t_timestamp=Just s}
        else do
          skip iprot _t3
          read_Column_t_fields iprot rec
      _ -> do
        skip iprot _t3
        readFieldEnd iprot
        read_Column_t_fields iprot rec
read_Column_t iprot = do
  readStructBegin iprot
  rec <- read_Column_t_fields iprot (Column_t{f_Column_t_columnName=Nothing,f_Column_t_value=Nothing,f_Column_t_timestamp=Nothing})
  readStructEnd iprot
  return rec
data Batch_mutation_t = Batch_mutation_t{f_Batch_mutation_t_table :: Maybe ([Char]),f_Batch_mutation_t_key :: Maybe ([Char]),f_Batch_mutation_t_cfmap :: Maybe (Map.Map ([Char]) ([Column_t]))} deriving (Show,Eq,Ord,Typeable)
write_Batch_mutation_t oprot rec = do
  writeStructBegin oprot "Batch_mutation_t"
  case f_Batch_mutation_t_table rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_Batch_mutation_t_key rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("key",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_Batch_mutation_t_cfmap rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("cfmap",T_MAP,3)
    (let {f [] = return (); f ((_kiter7,_viter8):t) = do {do {writeString oprot _kiter7;(let {f [] = return (); f (_viter9:t) = do {write_Column_t oprot _viter9;f t}} in do {writeListBegin oprot (T_STRUCT,length _viter8); f _viter8;writeListEnd oprot})};f t}} in do {writeMapBegin oprot (T_STRING,T_LIST,Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Batch_mutation_t_fields iprot rec = do
  (_,_t11,_id12) <- readFieldBegin iprot
  if _t11 == T_STOP then return rec else
    case _id12 of 
      1 -> if _t11 == T_STRING then do
        s <- readString iprot
        read_Batch_mutation_t_fields iprot rec{f_Batch_mutation_t_table=Just s}
        else do
          skip iprot _t11
          read_Batch_mutation_t_fields iprot rec
      2 -> if _t11 == T_STRING then do
        s <- readString iprot
        read_Batch_mutation_t_fields iprot rec{f_Batch_mutation_t_key=Just s}
        else do
          skip iprot _t11
          read_Batch_mutation_t_fields iprot rec
      3 -> if _t11 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readString iprot; v <- (let {f 0 = return []; f n = do {v <- (read_Column_t iprot);r <- f (n-1); return $ v:r}} in do {(_etype21,_size18) <- readListBegin iprot; f _size18});r <- f (n-1); return $ (k,v):r}} in do {(_ktype14,_vtype15,_size13) <- readMapBegin iprot; l <- f _size13; return $ Map.fromList l})
        read_Batch_mutation_t_fields iprot rec{f_Batch_mutation_t_cfmap=Just s}
        else do
          skip iprot _t11
          read_Batch_mutation_t_fields iprot rec
      _ -> do
        skip iprot _t11
        readFieldEnd iprot
        read_Batch_mutation_t_fields iprot rec
read_Batch_mutation_t iprot = do
  readStructBegin iprot
  rec <- read_Batch_mutation_t_fields iprot (Batch_mutation_t{f_Batch_mutation_t_table=Nothing,f_Batch_mutation_t_key=Nothing,f_Batch_mutation_t_cfmap=Nothing})
  readStructEnd iprot
  return rec
data SuperColumn_t = SuperColumn_t{f_SuperColumn_t_name :: Maybe ([Char]),f_SuperColumn_t_columns :: Maybe ([Column_t])} deriving (Show,Eq,Ord,Typeable)
write_SuperColumn_t oprot rec = do
  writeStructBegin oprot "SuperColumn_t"
  case f_SuperColumn_t_name rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_SuperColumn_t_columns rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,2)
    (let {f [] = return (); f (_viter25:t) = do {write_Column_t oprot _viter25;f t}} in do {writeListBegin oprot (T_STRUCT,length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_SuperColumn_t_fields iprot rec = do
  (_,_t27,_id28) <- readFieldBegin iprot
  if _t27 == T_STOP then return rec else
    case _id28 of 
      1 -> if _t27 == T_STRING then do
        s <- readString iprot
        read_SuperColumn_t_fields iprot rec{f_SuperColumn_t_name=Just s}
        else do
          skip iprot _t27
          read_SuperColumn_t_fields iprot rec
      2 -> if _t27 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_Column_t iprot);r <- f (n-1); return $ v:r}} in do {(_etype32,_size29) <- readListBegin iprot; f _size29})
        read_SuperColumn_t_fields iprot rec{f_SuperColumn_t_columns=Just s}
        else do
          skip iprot _t27
          read_SuperColumn_t_fields iprot rec
      _ -> do
        skip iprot _t27
        readFieldEnd iprot
        read_SuperColumn_t_fields iprot rec
read_SuperColumn_t iprot = do
  readStructBegin iprot
  rec <- read_SuperColumn_t_fields iprot (SuperColumn_t{f_SuperColumn_t_name=Nothing,f_SuperColumn_t_columns=Nothing})
  readStructEnd iprot
  return rec
data Batch_mutation_super_t = Batch_mutation_super_t{f_Batch_mutation_super_t_table :: Maybe ([Char]),f_Batch_mutation_super_t_key :: Maybe ([Char]),f_Batch_mutation_super_t_cfmap :: Maybe (Map.Map ([Char]) ([SuperColumn_t]))} deriving (Show,Eq,Ord,Typeable)
write_Batch_mutation_super_t oprot rec = do
  writeStructBegin oprot "Batch_mutation_super_t"
  case f_Batch_mutation_super_t_table rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_Batch_mutation_super_t_key rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("key",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_Batch_mutation_super_t_cfmap rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("cfmap",T_MAP,3)
    (let {f [] = return (); f ((_kiter36,_viter37):t) = do {do {writeString oprot _kiter36;(let {f [] = return (); f (_viter38:t) = do {write_SuperColumn_t oprot _viter38;f t}} in do {writeListBegin oprot (T_STRUCT,length _viter37); f _viter37;writeListEnd oprot})};f t}} in do {writeMapBegin oprot (T_STRING,T_LIST,Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Batch_mutation_super_t_fields iprot rec = do
  (_,_t40,_id41) <- readFieldBegin iprot
  if _t40 == T_STOP then return rec else
    case _id41 of 
      1 -> if _t40 == T_STRING then do
        s <- readString iprot
        read_Batch_mutation_super_t_fields iprot rec{f_Batch_mutation_super_t_table=Just s}
        else do
          skip iprot _t40
          read_Batch_mutation_super_t_fields iprot rec
      2 -> if _t40 == T_STRING then do
        s <- readString iprot
        read_Batch_mutation_super_t_fields iprot rec{f_Batch_mutation_super_t_key=Just s}
        else do
          skip iprot _t40
          read_Batch_mutation_super_t_fields iprot rec
      3 -> if _t40 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readString iprot; v <- (let {f 0 = return []; f n = do {v <- (read_SuperColumn_t iprot);r <- f (n-1); return $ v:r}} in do {(_etype50,_size47) <- readListBegin iprot; f _size47});r <- f (n-1); return $ (k,v):r}} in do {(_ktype43,_vtype44,_size42) <- readMapBegin iprot; l <- f _size42; return $ Map.fromList l})
        read_Batch_mutation_super_t_fields iprot rec{f_Batch_mutation_super_t_cfmap=Just s}
        else do
          skip iprot _t40
          read_Batch_mutation_super_t_fields iprot rec
      _ -> do
        skip iprot _t40
        readFieldEnd iprot
        read_Batch_mutation_super_t_fields iprot rec
read_Batch_mutation_super_t iprot = do
  readStructBegin iprot
  rec <- read_Batch_mutation_super_t_fields iprot (Batch_mutation_super_t{f_Batch_mutation_super_t_table=Nothing,f_Batch_mutation_super_t_key=Nothing,f_Batch_mutation_super_t_cfmap=Nothing})
  readStructEnd iprot
  return rec
type Column_family_map = Map.Map ([Char]) ([Column_t])

type SuperColumn_family_map = Map.Map ([Char]) ([SuperColumn_t])

