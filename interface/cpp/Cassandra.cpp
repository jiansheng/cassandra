/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#include "Cassandra.h"

namespace com { namespace facebook { namespace infrastructure { namespace service {

uint32_t Cassandra_get_slice_args::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case -1:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -2:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -3:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnFamily_column);
          this->__isset.columnFamily_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -4:
        if (ftype == facebook::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -5:
        if (ftype == facebook::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_slice_args::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_get_slice_args");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily_column", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString(this->columnFamily_column);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("start", facebook::thrift::protocol::T_I32, -4);
  xfer += oprot->writeI32(this->start);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("count", facebook::thrift::protocol::T_I32, -5);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_slice_pargs::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_get_slice_pargs");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString((*(this->tablename)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily_column", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString((*(this->columnFamily_column)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("start", facebook::thrift::protocol::T_I32, -4);
  xfer += oprot->writeI32((*(this->start)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("count", facebook::thrift::protocol::T_I32, -5);
  xfer += oprot->writeI32((*(this->count)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_slice_result::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size34;
            facebook::thrift::protocol::TType _etype37;
            iprot->readListBegin(_etype37, _size34);
            this->success.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += this->success[_i38].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_slice_result::write(facebook::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Cassandra_get_slice_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", facebook::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(facebook::thrift::protocol::T_STRUCT, this->success.size());
      std::vector<column_t> ::const_iterator _iter39;
      for (_iter39 = this->success.begin(); _iter39 != this->success.end(); ++_iter39)
      {
        xfer += (*_iter39).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_slice_presult::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size40;
            facebook::thrift::protocol::TType _etype43;
            iprot->readListBegin(_etype43, _size40);
            (*(this->success)).resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += (*(this->success))[_i44].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_column_args::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case -1:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -2:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -3:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnFamily_column);
          this->__isset.columnFamily_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_column_args::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_get_column_args");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily_column", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString(this->columnFamily_column);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_column_pargs::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_get_column_pargs");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString((*(this->tablename)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily_column", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString((*(this->columnFamily_column)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_column_result::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_column_result::write(facebook::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Cassandra_get_column_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", facebook::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_column_presult::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_column_count_args::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case -1:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -2:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -3:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnFamily_column);
          this->__isset.columnFamily_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_column_count_args::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_get_column_count_args");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily_column", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString(this->columnFamily_column);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_column_count_pargs::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_get_column_count_pargs");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString((*(this->tablename)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily_column", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString((*(this->columnFamily_column)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_column_count_result::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_column_count_result::write(facebook::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Cassandra_get_column_count_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", facebook::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_column_count_presult::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_insert_args::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case -1:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -2:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -3:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnFamily_column);
          this->__isset.columnFamily_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -4:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cellData);
          this->__isset.cellData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -5:
        if (ftype == facebook::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_insert_args::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_insert_args");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily_column", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString(this->columnFamily_column);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("cellData", facebook::thrift::protocol::T_STRING, -4);
  xfer += oprot->writeString(this->cellData);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("timestamp", facebook::thrift::protocol::T_I32, -5);
  xfer += oprot->writeI32(this->timestamp);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_insert_pargs::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_insert_pargs");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString((*(this->tablename)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily_column", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString((*(this->columnFamily_column)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("cellData", facebook::thrift::protocol::T_STRING, -4);
  xfer += oprot->writeString((*(this->cellData)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("timestamp", facebook::thrift::protocol::T_I32, -5);
  xfer += oprot->writeI32((*(this->timestamp)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_batch_insert_args::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case -1:
        if (ftype == facebook::thrift::protocol::T_STRUCT) {
          xfer += this->batchMutation.read(iprot);
          this->__isset.batchMutation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_batch_insert_args::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_batch_insert_args");
  xfer += oprot->writeFieldBegin("batchMutation", facebook::thrift::protocol::T_STRUCT, -1);
  xfer += this->batchMutation.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_batch_insert_pargs::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_batch_insert_pargs");
  xfer += oprot->writeFieldBegin("batchMutation", facebook::thrift::protocol::T_STRUCT, -1);
  xfer += (*(this->batchMutation)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_batch_insert_blocking_args::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case -1:
        if (ftype == facebook::thrift::protocol::T_STRUCT) {
          xfer += this->batchMutation.read(iprot);
          this->__isset.batchMutation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_batch_insert_blocking_args::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_batch_insert_blocking_args");
  xfer += oprot->writeFieldBegin("batchMutation", facebook::thrift::protocol::T_STRUCT, -1);
  xfer += this->batchMutation.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_batch_insert_blocking_pargs::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_batch_insert_blocking_pargs");
  xfer += oprot->writeFieldBegin("batchMutation", facebook::thrift::protocol::T_STRUCT, -1);
  xfer += (*(this->batchMutation)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_batch_insert_blocking_result::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_batch_insert_blocking_result::write(facebook::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Cassandra_batch_insert_blocking_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", facebook::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_batch_insert_blocking_presult::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_remove_args::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case -1:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -2:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -3:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnFamily_column);
          this->__isset.columnFamily_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_remove_args::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_remove_args");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily_column", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString(this->columnFamily_column);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_remove_pargs::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_remove_pargs");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString((*(this->tablename)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily_column", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString((*(this->columnFamily_column)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_slice_super_args::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case -1:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -2:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -3:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnFamily_superColumnName);
          this->__isset.columnFamily_superColumnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -4:
        if (ftype == facebook::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -5:
        if (ftype == facebook::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_slice_super_args::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_get_slice_super_args");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily_superColumnName", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString(this->columnFamily_superColumnName);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("start", facebook::thrift::protocol::T_I32, -4);
  xfer += oprot->writeI32(this->start);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("count", facebook::thrift::protocol::T_I32, -5);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_slice_super_pargs::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_get_slice_super_pargs");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString((*(this->tablename)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily_superColumnName", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString((*(this->columnFamily_superColumnName)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("start", facebook::thrift::protocol::T_I32, -4);
  xfer += oprot->writeI32((*(this->start)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("count", facebook::thrift::protocol::T_I32, -5);
  xfer += oprot->writeI32((*(this->count)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_slice_super_result::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size45;
            facebook::thrift::protocol::TType _etype48;
            iprot->readListBegin(_etype48, _size45);
            this->success.resize(_size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              xfer += this->success[_i49].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_slice_super_result::write(facebook::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Cassandra_get_slice_super_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", facebook::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(facebook::thrift::protocol::T_STRUCT, this->success.size());
      std::vector<superColumn_t> ::const_iterator _iter50;
      for (_iter50 = this->success.begin(); _iter50 != this->success.end(); ++_iter50)
      {
        xfer += (*_iter50).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_slice_super_presult::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size51;
            facebook::thrift::protocol::TType _etype54;
            iprot->readListBegin(_etype54, _size51);
            (*(this->success)).resize(_size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              xfer += (*(this->success))[_i55].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_superColumn_args::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case -1:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tablename);
          this->__isset.tablename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -2:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case -3:
        if (ftype == facebook::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnFamily);
          this->__isset.columnFamily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_superColumn_args::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_get_superColumn_args");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString(this->tablename);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString(this->columnFamily);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_superColumn_pargs::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_get_superColumn_pargs");
  xfer += oprot->writeFieldBegin("tablename", facebook::thrift::protocol::T_STRING, -1);
  xfer += oprot->writeString((*(this->tablename)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", facebook::thrift::protocol::T_STRING, -2);
  xfer += oprot->writeString((*(this->key)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("columnFamily", facebook::thrift::protocol::T_STRING, -3);
  xfer += oprot->writeString((*(this->columnFamily)));
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_superColumn_result::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_get_superColumn_result::write(facebook::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Cassandra_get_superColumn_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", facebook::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_get_superColumn_presult::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_batch_insert_superColumn_args::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case -1:
        if (ftype == facebook::thrift::protocol::T_STRUCT) {
          xfer += this->batchMutationSuper.read(iprot);
          this->__isset.batchMutationSuper = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_batch_insert_superColumn_args::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_batch_insert_superColumn_args");
  xfer += oprot->writeFieldBegin("batchMutationSuper", facebook::thrift::protocol::T_STRUCT, -1);
  xfer += this->batchMutationSuper.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_batch_insert_superColumn_pargs::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_batch_insert_superColumn_pargs");
  xfer += oprot->writeFieldBegin("batchMutationSuper", facebook::thrift::protocol::T_STRUCT, -1);
  xfer += (*(this->batchMutationSuper)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_batch_insert_superColumn_blocking_args::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case -1:
        if (ftype == facebook::thrift::protocol::T_STRUCT) {
          xfer += this->batchMutationSuper.read(iprot);
          this->__isset.batchMutationSuper = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_batch_insert_superColumn_blocking_args::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_batch_insert_superColumn_blocking_args");
  xfer += oprot->writeFieldBegin("batchMutationSuper", facebook::thrift::protocol::T_STRUCT, -1);
  xfer += this->batchMutationSuper.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_batch_insert_superColumn_blocking_pargs::write(facebook::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Cassandra_batch_insert_superColumn_blocking_pargs");
  xfer += oprot->writeFieldBegin("batchMutationSuper", facebook::thrift::protocol::T_STRUCT, -1);
  xfer += (*(this->batchMutationSuper)).write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_batch_insert_superColumn_blocking_result::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cassandra_batch_insert_superColumn_blocking_result::write(facebook::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Cassandra_batch_insert_superColumn_blocking_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", facebook::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t Cassandra_batch_insert_superColumn_blocking_presult::read(facebook::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  facebook::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using facebook::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == facebook::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == facebook::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void CassandraClient::get_slice(std::vector<column_t> & _return, const std::string& tablename, const std::string& key, const std::string& columnFamily_column, const int32_t start, const int32_t count)
{
  send_get_slice(tablename, key, columnFamily_column, start, count);
  recv_get_slice(_return);
}

void CassandraClient::send_get_slice(const std::string& tablename, const std::string& key, const std::string& columnFamily_column, const int32_t start, const int32_t count)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_slice", facebook::thrift::protocol::T_CALL, cseqid);

  Cassandra_get_slice_pargs args;
  args.tablename = &tablename;
  args.key = &key;
  args.columnFamily_column = &columnFamily_column;
  args.start = &start;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->flush();
  oprot_->getTransport()->writeEnd();
}

void CassandraClient::recv_get_slice(std::vector<column_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  facebook::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == facebook::thrift::protocol::T_EXCEPTION) {
    facebook::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != facebook::thrift::protocol::T_REPLY) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("get_slice") != 0) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  Cassandra_get_slice_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::MISSING_RESULT, "get_slice failed: unknown result");
}

void CassandraClient::get_column(column_t& _return, const std::string& tablename, const std::string& key, const std::string& columnFamily_column)
{
  send_get_column(tablename, key, columnFamily_column);
  recv_get_column(_return);
}

void CassandraClient::send_get_column(const std::string& tablename, const std::string& key, const std::string& columnFamily_column)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_column", facebook::thrift::protocol::T_CALL, cseqid);

  Cassandra_get_column_pargs args;
  args.tablename = &tablename;
  args.key = &key;
  args.columnFamily_column = &columnFamily_column;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->flush();
  oprot_->getTransport()->writeEnd();
}

void CassandraClient::recv_get_column(column_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  facebook::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == facebook::thrift::protocol::T_EXCEPTION) {
    facebook::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != facebook::thrift::protocol::T_REPLY) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("get_column") != 0) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  Cassandra_get_column_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::MISSING_RESULT, "get_column failed: unknown result");
}

int32_t CassandraClient::get_column_count(const std::string& tablename, const std::string& key, const std::string& columnFamily_column)
{
  send_get_column_count(tablename, key, columnFamily_column);
  return recv_get_column_count();
}

void CassandraClient::send_get_column_count(const std::string& tablename, const std::string& key, const std::string& columnFamily_column)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_column_count", facebook::thrift::protocol::T_CALL, cseqid);

  Cassandra_get_column_count_pargs args;
  args.tablename = &tablename;
  args.key = &key;
  args.columnFamily_column = &columnFamily_column;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->flush();
  oprot_->getTransport()->writeEnd();
}

int32_t CassandraClient::recv_get_column_count()
{

  int32_t rseqid = 0;
  std::string fname;
  facebook::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == facebook::thrift::protocol::T_EXCEPTION) {
    facebook::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != facebook::thrift::protocol::T_REPLY) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("get_column_count") != 0) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  int32_t _return;
  Cassandra_get_column_count_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::MISSING_RESULT, "get_column_count failed: unknown result");
}

void CassandraClient::insert(const std::string& tablename, const std::string& key, const std::string& columnFamily_column, const std::string& cellData, const int32_t timestamp)
{
  send_insert(tablename, key, columnFamily_column, cellData, timestamp);
}

void CassandraClient::send_insert(const std::string& tablename, const std::string& key, const std::string& columnFamily_column, const std::string& cellData, const int32_t timestamp)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("insert", facebook::thrift::protocol::T_CALL, cseqid);

  Cassandra_insert_pargs args;
  args.tablename = &tablename;
  args.key = &key;
  args.columnFamily_column = &columnFamily_column;
  args.cellData = &cellData;
  args.timestamp = &timestamp;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->flush();
  oprot_->getTransport()->writeEnd();
}

void CassandraClient::batch_insert(const batch_mutation_t& batchMutation)
{
  send_batch_insert(batchMutation);
}

void CassandraClient::send_batch_insert(const batch_mutation_t& batchMutation)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batch_insert", facebook::thrift::protocol::T_CALL, cseqid);

  Cassandra_batch_insert_pargs args;
  args.batchMutation = &batchMutation;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->flush();
  oprot_->getTransport()->writeEnd();
}

bool CassandraClient::batch_insert_blocking(const batch_mutation_t& batchMutation)
{
  send_batch_insert_blocking(batchMutation);
  return recv_batch_insert_blocking();
}

void CassandraClient::send_batch_insert_blocking(const batch_mutation_t& batchMutation)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batch_insert_blocking", facebook::thrift::protocol::T_CALL, cseqid);

  Cassandra_batch_insert_blocking_pargs args;
  args.batchMutation = &batchMutation;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->flush();
  oprot_->getTransport()->writeEnd();
}

bool CassandraClient::recv_batch_insert_blocking()
{

  int32_t rseqid = 0;
  std::string fname;
  facebook::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == facebook::thrift::protocol::T_EXCEPTION) {
    facebook::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != facebook::thrift::protocol::T_REPLY) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("batch_insert_blocking") != 0) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  bool _return;
  Cassandra_batch_insert_blocking_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::MISSING_RESULT, "batch_insert_blocking failed: unknown result");
}

void CassandraClient::remove(const std::string& tablename, const std::string& key, const std::string& columnFamily_column)
{
  send_remove(tablename, key, columnFamily_column);
}

void CassandraClient::send_remove(const std::string& tablename, const std::string& key, const std::string& columnFamily_column)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("remove", facebook::thrift::protocol::T_CALL, cseqid);

  Cassandra_remove_pargs args;
  args.tablename = &tablename;
  args.key = &key;
  args.columnFamily_column = &columnFamily_column;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->flush();
  oprot_->getTransport()->writeEnd();
}

void CassandraClient::get_slice_super(std::vector<superColumn_t> & _return, const std::string& tablename, const std::string& key, const std::string& columnFamily_superColumnName, const int32_t start, const int32_t count)
{
  send_get_slice_super(tablename, key, columnFamily_superColumnName, start, count);
  recv_get_slice_super(_return);
}

void CassandraClient::send_get_slice_super(const std::string& tablename, const std::string& key, const std::string& columnFamily_superColumnName, const int32_t start, const int32_t count)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_slice_super", facebook::thrift::protocol::T_CALL, cseqid);

  Cassandra_get_slice_super_pargs args;
  args.tablename = &tablename;
  args.key = &key;
  args.columnFamily_superColumnName = &columnFamily_superColumnName;
  args.start = &start;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->flush();
  oprot_->getTransport()->writeEnd();
}

void CassandraClient::recv_get_slice_super(std::vector<superColumn_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  facebook::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == facebook::thrift::protocol::T_EXCEPTION) {
    facebook::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != facebook::thrift::protocol::T_REPLY) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("get_slice_super") != 0) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  Cassandra_get_slice_super_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::MISSING_RESULT, "get_slice_super failed: unknown result");
}

void CassandraClient::get_superColumn(superColumn_t& _return, const std::string& tablename, const std::string& key, const std::string& columnFamily)
{
  send_get_superColumn(tablename, key, columnFamily);
  recv_get_superColumn(_return);
}

void CassandraClient::send_get_superColumn(const std::string& tablename, const std::string& key, const std::string& columnFamily)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_superColumn", facebook::thrift::protocol::T_CALL, cseqid);

  Cassandra_get_superColumn_pargs args;
  args.tablename = &tablename;
  args.key = &key;
  args.columnFamily = &columnFamily;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->flush();
  oprot_->getTransport()->writeEnd();
}

void CassandraClient::recv_get_superColumn(superColumn_t& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  facebook::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == facebook::thrift::protocol::T_EXCEPTION) {
    facebook::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != facebook::thrift::protocol::T_REPLY) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("get_superColumn") != 0) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  Cassandra_get_superColumn_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::MISSING_RESULT, "get_superColumn failed: unknown result");
}

void CassandraClient::batch_insert_superColumn(const batch_mutation_super_t& batchMutationSuper)
{
  send_batch_insert_superColumn(batchMutationSuper);
}

void CassandraClient::send_batch_insert_superColumn(const batch_mutation_super_t& batchMutationSuper)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batch_insert_superColumn", facebook::thrift::protocol::T_CALL, cseqid);

  Cassandra_batch_insert_superColumn_pargs args;
  args.batchMutationSuper = &batchMutationSuper;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->flush();
  oprot_->getTransport()->writeEnd();
}

bool CassandraClient::batch_insert_superColumn_blocking(const batch_mutation_super_t& batchMutationSuper)
{
  send_batch_insert_superColumn_blocking(batchMutationSuper);
  return recv_batch_insert_superColumn_blocking();
}

void CassandraClient::send_batch_insert_superColumn_blocking(const batch_mutation_super_t& batchMutationSuper)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("batch_insert_superColumn_blocking", facebook::thrift::protocol::T_CALL, cseqid);

  Cassandra_batch_insert_superColumn_blocking_pargs args;
  args.batchMutationSuper = &batchMutationSuper;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->flush();
  oprot_->getTransport()->writeEnd();
}

bool CassandraClient::recv_batch_insert_superColumn_blocking()
{

  int32_t rseqid = 0;
  std::string fname;
  facebook::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == facebook::thrift::protocol::T_EXCEPTION) {
    facebook::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != facebook::thrift::protocol::T_REPLY) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
  }
  if (fname.compare("batch_insert_superColumn_blocking") != 0) {
    iprot_->skip(facebook::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME);
  }
  bool _return;
  Cassandra_batch_insert_superColumn_blocking_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::MISSING_RESULT, "batch_insert_superColumn_blocking failed: unknown result");
}

bool CassandraProcessor::process(boost::shared_ptr<facebook::thrift::protocol::TProtocol> piprot, boost::shared_ptr<facebook::thrift::protocol::TProtocol> poprot) {

  facebook::thrift::protocol::TProtocol* iprot = piprot.get();
  facebook::thrift::protocol::TProtocol* oprot = poprot.get();
  std::string fname;
  facebook::thrift::protocol::TMessageType mtype;
  int32_t seqid;

  iprot->readMessageBegin(fname, mtype, seqid);

  if (mtype != facebook::thrift::protocol::T_CALL) {
    iprot->skip(facebook::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    facebook::thrift::TApplicationException x(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE);
    oprot->writeMessageBegin(fname, facebook::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->flush();
    oprot->getTransport()->writeEnd();
    return true;
  }

  return process_fn(iprot, oprot, fname, seqid);
}

bool CassandraProcessor::process_fn(facebook::thrift::protocol::TProtocol* iprot, facebook::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid) {
  std::map<std::string, void (CassandraProcessor::*)(int32_t, facebook::thrift::protocol::TProtocol*, facebook::thrift::protocol::TProtocol*)>::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return facebook::fb303::FacebookServiceProcessor::process_fn(iprot, oprot, fname, seqid);
  }
  (this->*(pfn->second))(seqid, iprot, oprot);
  return true;
}

void CassandraProcessor::process_get_slice(int32_t seqid, facebook::thrift::protocol::TProtocol* iprot, facebook::thrift::protocol::TProtocol* oprot)
{
  Cassandra_get_slice_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  iprot->getTransport()->readEnd();

  Cassandra_get_slice_result result;
  try {
    iface_->get_slice(result.success, args.tablename, args.key, args.columnFamily_column, args.start, args.count);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    facebook::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_slice", facebook::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->flush();
    oprot->getTransport()->writeEnd();
    return;
  }

  oprot->writeMessageBegin("get_slice", facebook::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  oprot->getTransport()->flush();
  oprot->getTransport()->writeEnd();
}

void CassandraProcessor::process_get_column(int32_t seqid, facebook::thrift::protocol::TProtocol* iprot, facebook::thrift::protocol::TProtocol* oprot)
{
  Cassandra_get_column_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  iprot->getTransport()->readEnd();

  Cassandra_get_column_result result;
  try {
    iface_->get_column(result.success, args.tablename, args.key, args.columnFamily_column);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    facebook::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_column", facebook::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->flush();
    oprot->getTransport()->writeEnd();
    return;
  }

  oprot->writeMessageBegin("get_column", facebook::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  oprot->getTransport()->flush();
  oprot->getTransport()->writeEnd();
}

void CassandraProcessor::process_get_column_count(int32_t seqid, facebook::thrift::protocol::TProtocol* iprot, facebook::thrift::protocol::TProtocol* oprot)
{
  Cassandra_get_column_count_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  iprot->getTransport()->readEnd();

  Cassandra_get_column_count_result result;
  try {
    result.success = iface_->get_column_count(args.tablename, args.key, args.columnFamily_column);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    facebook::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_column_count", facebook::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->flush();
    oprot->getTransport()->writeEnd();
    return;
  }

  oprot->writeMessageBegin("get_column_count", facebook::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  oprot->getTransport()->flush();
  oprot->getTransport()->writeEnd();
}

void CassandraProcessor::process_insert(int32_t seqid, facebook::thrift::protocol::TProtocol* iprot, facebook::thrift::protocol::TProtocol* oprot)
{
  Cassandra_insert_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  iprot->getTransport()->readEnd();

  try {
    iface_->insert(args.tablename, args.key, args.columnFamily_column, args.cellData, args.timestamp);
  } catch (const std::exception& e) {
  }
  return;
}

void CassandraProcessor::process_batch_insert(int32_t seqid, facebook::thrift::protocol::TProtocol* iprot, facebook::thrift::protocol::TProtocol* oprot)
{
  Cassandra_batch_insert_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  iprot->getTransport()->readEnd();

  try {
    iface_->batch_insert(args.batchMutation);
  } catch (const std::exception& e) {
  }
  return;
}

void CassandraProcessor::process_batch_insert_blocking(int32_t seqid, facebook::thrift::protocol::TProtocol* iprot, facebook::thrift::protocol::TProtocol* oprot)
{
  Cassandra_batch_insert_blocking_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  iprot->getTransport()->readEnd();

  Cassandra_batch_insert_blocking_result result;
  try {
    result.success = iface_->batch_insert_blocking(args.batchMutation);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    facebook::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batch_insert_blocking", facebook::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->flush();
    oprot->getTransport()->writeEnd();
    return;
  }

  oprot->writeMessageBegin("batch_insert_blocking", facebook::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  oprot->getTransport()->flush();
  oprot->getTransport()->writeEnd();
}

void CassandraProcessor::process_remove(int32_t seqid, facebook::thrift::protocol::TProtocol* iprot, facebook::thrift::protocol::TProtocol* oprot)
{
  Cassandra_remove_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  iprot->getTransport()->readEnd();

  try {
    iface_->remove(args.tablename, args.key, args.columnFamily_column);
  } catch (const std::exception& e) {
  }
  return;
}

void CassandraProcessor::process_get_slice_super(int32_t seqid, facebook::thrift::protocol::TProtocol* iprot, facebook::thrift::protocol::TProtocol* oprot)
{
  Cassandra_get_slice_super_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  iprot->getTransport()->readEnd();

  Cassandra_get_slice_super_result result;
  try {
    iface_->get_slice_super(result.success, args.tablename, args.key, args.columnFamily_superColumnName, args.start, args.count);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    facebook::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_slice_super", facebook::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->flush();
    oprot->getTransport()->writeEnd();
    return;
  }

  oprot->writeMessageBegin("get_slice_super", facebook::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  oprot->getTransport()->flush();
  oprot->getTransport()->writeEnd();
}

void CassandraProcessor::process_get_superColumn(int32_t seqid, facebook::thrift::protocol::TProtocol* iprot, facebook::thrift::protocol::TProtocol* oprot)
{
  Cassandra_get_superColumn_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  iprot->getTransport()->readEnd();

  Cassandra_get_superColumn_result result;
  try {
    iface_->get_superColumn(result.success, args.tablename, args.key, args.columnFamily);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    facebook::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_superColumn", facebook::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->flush();
    oprot->getTransport()->writeEnd();
    return;
  }

  oprot->writeMessageBegin("get_superColumn", facebook::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  oprot->getTransport()->flush();
  oprot->getTransport()->writeEnd();
}

void CassandraProcessor::process_batch_insert_superColumn(int32_t seqid, facebook::thrift::protocol::TProtocol* iprot, facebook::thrift::protocol::TProtocol* oprot)
{
  Cassandra_batch_insert_superColumn_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  iprot->getTransport()->readEnd();

  try {
    iface_->batch_insert_superColumn(args.batchMutationSuper);
  } catch (const std::exception& e) {
  }
  return;
}

void CassandraProcessor::process_batch_insert_superColumn_blocking(int32_t seqid, facebook::thrift::protocol::TProtocol* iprot, facebook::thrift::protocol::TProtocol* oprot)
{
  Cassandra_batch_insert_superColumn_blocking_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  iprot->getTransport()->readEnd();

  Cassandra_batch_insert_superColumn_blocking_result result;
  try {
    result.success = iface_->batch_insert_superColumn_blocking(args.batchMutationSuper);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    facebook::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("batch_insert_superColumn_blocking", facebook::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->flush();
    oprot->getTransport()->writeEnd();
    return;
  }

  oprot->writeMessageBegin("batch_insert_superColumn_blocking", facebook::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  oprot->getTransport()->flush();
  oprot->getTransport()->writeEnd();
}

}}}} // namespace

